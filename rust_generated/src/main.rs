/*

* Code generated by Symars. Thank you for using Symars!
  Symars is licensed under MIT licnese.
  Repository: https://github.com/Da1sypetals/Symars

* Computation code is not intended for manual editing.

* If you find an error,
  or if you believe Symars generates incorrect result,
  please raise an issue under our repo with minimal reproducible example.

*/

#[inline]
pub fn many_many(a: f64, b: f64, c: f64, d: f64, e: f64, f: f64, g: f64, h: f64) -> f64 {
    ((-1_f64)
        * (((((((d) * ((e).recip())) + ((((-1_f64) * (h)) + ((f) * (g))).ln())).abs()).cbrt())
            * ((c).cosh())
            * (if (a) * ((a) + (b) + ((-1_f64) * (c))) != 0_f64 {
                ((((a) * ((a) + (b) + ((-1_f64) * (c)))).sin()) / (a)
                    * ((a) + (b) + ((-1_f64) * (c))))
            } else {
                1_f64
            }))
        .tanh()))
        + ((((((b) + (((c) + ((-1_f64) * (a))).cbrt())).sqrt()).exp()) + (((a).ln()).sin())).abs())
}

fn main() {
    let z = many_many(1.0, 1.0, 5.0, 1.0, 1.0, 1.0, 1.0, 1.0);
    dbg!(z); // [src/main.rs:32:5] z = 3.9955126397520866
}
