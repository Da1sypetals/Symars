
/*

* Code generated by Symars. Thank you for using Symars!
  Symars is licensed under MIT licnese.
  Repository: https://github.com/Da1sypetals/Symars

* Computation code is not intended for manual editing.

* If you find an error,
  or if you believe Symars generates incorrect result, 
  please raise an issue under our repo with minimal reproducible example.

*/




#[inline]
pub  fn test_col_0_0(a: f32, b: f32, c: f32, d: f32) -> f32 {

    (((b).exp()) * ((a).ln())) + (((c) + (d)).ln())

}




#[inline]
pub const fn test_col_1_0(a: f32, b: f32, c: f32, d: f32) -> f32 {

    1_f32

}




#[inline]
pub  fn test_col_2_0(a: f32, b: f32, c: f32, d: f32) -> f32 {

    ((c).max(d)) + ((a).min(b))

}


pub fn test_col(mut vec: faer::ColMut<f32>, a: f32, b: f32, c: f32, d: f32) {

    
vec[0] = test_col_0_0(a, b, c, d);


vec[1] = test_col_1_0(a, b, c, d);


vec[2] = test_col_2_0(a, b, c, d);

    
}

/*

* Code generated by Symars. Thank you for using Symars!
  Symars is licensed under MIT licnese.
  Repository: https://github.com/Da1sypetals/Symars

* Computation code is not intended for manual editing.

* If you find an error,
  or if you believe Symars generates incorrect result, 
  please raise an issue under our repo with minimal reproducible example.

*/




#[inline]
pub const fn test_row_0_0(a: f64, b: f64) -> f64 {

    0_f64

}




#[inline]
pub const fn test_row_0_1(a: f64, b: f64) -> f64 {

    1_f64

}




#[inline]
pub  fn test_row_0_2(a: f64, b: f64) -> f64 {

    (-3_f64) + ((2_f64) * (b)) + ((3.50000000000000_f64) * (a))

}


pub fn test_row(mut vec: faer::RowMut<f64>, a: f64, b: f64) {

    
vec[0] = test_row_0_0(a, b);


vec[1] = test_row_0_1(a, b);


vec[2] = test_row_0_2(a, b);

    
}
